# 永久代

- 方法区

- 在JDK8之前的HotSpot实现中，类的元数据如方法数据、方法信息（字节码，栈和变量大小）、运行时常量池、已确定的符号引用和虚方法表等被保存在永久代中

- 32位默认永久代的大小为64M
- 64位默认为85M
- 可通过参数-XX:MaxPermSize进行设置
- 一旦类的元数据超过了永久代大小，就会抛出OOM异常



# 元空间

- Metaspace 

- 虚拟机团队在JDK8的HotSpot中，把永久代从Java堆中移除了
- 把类的元数据直接保存在本地内存区域（堆外内存 Non-heap），称之为元空间
- 元数据信息直接存储在==本地内存区域==



## 好处

- 把永久代从Java堆中移除了，并把类的元数据直接保存在本地内存区域（堆外内存）。这样做有什么好处？

- 对永久代的调优过程非常困难，永久代的大小很难确定，其中涉及到太多因素
  - 如类的总数、常量池大小和方法数量等
  - 永久代的数据可能会随着每一次Full GC而发生移动

- 而在JDK8中，类的元数据保存在本地内存中，元空间的最大可分配空间就是系统可用内存空间
- 可避免永久代的内存溢出问题，不过需要监控内存的消耗情况，一旦发生内存泄漏，会占用大量的本地内存

- JDK7之前的HotSpot，字符串常量池的字符串被存储在永久代中，因此可能导致一系列的性能问题和内存溢出错误
- 在JDK8中，字符串常量池中只保存字符串的引用，弱引用



JDK 1.8 的对 JVM 架构的改造将类元数据放到本地内存中，另外，将常量池和静态变量放到 Java 堆里。HotSopt VM 将会为类的元数据明确分配和释放本地内存。在这种架构下，类元信息就突破了原来 -XX:MaxPermSize 的限制，现在可以使用更多的本地内存。这样就从一定程度上解决了原来在运行时生成大量类的造成经常 Full GC 问题，如运行时使用反射、代理等。

分配本地内存发给类元数据在一个称为「块」的数据结构上，不同类元数据将会用不同大小的块存放。每个块与一个类加载器相关联，并且所有被这个类加载器加载的类元数据在这个块下分配的空间存储元数据。不同的应用块的大小将会不同，块大小的分配将会被内部碎片和外部碎片所限制。当类加载器不再使用，所有和这个类加载器相关联的块空间将会被释放。

如果服务器内存足够，升级到 JDK 1.8 修改 JVM 参数最简单的办法就是将 -XX:PermSize 和 -XX:MaxPermSize 参数替换为 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize，因为现在里面只存元数据信息了，给它个大的空间肯定没问题。不过堆得空间因为现在要多存储原来在永久代的常量池和静态变量可能需要稍微扩大些。具体可以根据 GC 日志，和 $JAVA/bin 下的工具做一些权衡和调优