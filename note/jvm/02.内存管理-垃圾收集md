



# 概述

- GC
- Grabage Collection
- 哪些内存需要回收
  - 线程创建时，创建虚拟机栈，方法栈，程序计数器
    - 每个栈帧内的数据占用的内存已知并确定
    - 方法结束，线程结束，虚拟机栈内存释放
  - 堆和方法区不一样，需要考虑回收
    - 一个接口多个实现类，占用的内存不一样
    - 一个方法多个分支，占用内存不一样
    - 只有在运行时才会知道创建了那些对象
- 什么时候回收
- 如何回收



# 判断对象是否死亡



## 引用计数算法

- 对象添加一个引用计数器
  - 每当有一个方法调用，计数器+1
  - 引用失效，计数器-1
  - 计数器为0不可能再被引用
- 好处
  - 实现简单
- 不足
  - 无法解决==循环引用==的问题
    - 2个对象相互引用，但是2个对象都没有被其他方法调用
    - 计数算法无法通知GC回收它们



## 可达性分析算法

- Reachability Analysis

- 基本思路

  - 通过GC roots对象作为起始点，从该节点向下搜索

  - 搜索的路径是引用链 Reference Chain

  - 当一个对象到GC Roots没有任何引用链时，该对象不可用

    

<img src="img/7.png" alt="1577361686374" style="zoom:67%;" />

- 作为GC roots的对象包括如下几种
  - 虚拟机栈（栈帧中的局部变量表）中引用的对象
  - 方法区中静态属性引用的对象
  - 方法区中常量引用的对象
  - 本地方法栈中JNI引用的对象



# 关于引用

- jdk2 进行扩充
- 强引用
- 软引用
- 弱引用
- 虚引用
- 强度有高到低



## 强引用 Strong Reference

- 类似 Object obj  = new Object()
- 强引用存在，垃圾收集器不会回收掉被引用的对象



## 软引用 Soft Reference

- 描述一些有用但非必须的对象
- 系统发生内存溢出异常之前才会将这些对象进行二次回收
  - 如果还是没有足够内存，则抛出内存溢出异常



## 弱引用 Weak Reference

- 描述非必需对象
- 被弱引用关联的对象只能生存到下一次垃圾收集发生之前



## 虚引用 Phantom Reference

- 无法通过虚引用获取一个对象的实例
- 设置虚引用的用处是被收集器回收时收到一个系统通知



# 关于 finalize

- 一个对象的消亡至少需要标记2次
  - 当一个对象没有被GC roots引用，被第一次标记，进行第一次筛选
  - 筛选
    - 对象没有覆盖finalize方法
    - finalize方法被调用过
    - 2者满足，不调用对象的finalize方法
    - 不满足，放入F-Queue队列中
- 虚拟机自动建立的低优先级的Finalizer线程执行F-Queue队中对象的finalize方法
  - 执行后，再由GC进行标记



# 方法区回收

- 永久代，有的jvm没有在方法区实现垃圾回收

- 方法区的回收效率低



# 垃圾收集算法



## 标记-清除法

- 标记所有要回收的对象
- 标记完成后，统一回收所有被标记的对象
- 基础的收集算法
  - 后来收集算法在此基础上改进
- 不足
  - 效率问题
    - 标记和清除效率不高
  - 空间问题
    - 标记清除后产生大量的不连续的内存碎片
    - 内存碎片导致以后程序运行需要分配大对象时无法找到连续内存，导致提前触发另一次垃圾收集操作

<img src="img/8.png" alt="8" style="zoom: 80%;" />



## 复制算法

- 效率比标记-清除法高
- 将内存按容量划分为大小相等的2块
- 每次只使用一块
  - 当这一块快使用完了，将存活的对象复制到另一块中
  - 将已使用的块清除掉
- 每次对半块进行内存回收，分配内存时不用考虑内存碎片的情况
  - 只要移动顶部指针，按顺序分配内存即可
- 实现简单，运行高效
- 不足
  - 可以用的内存为原来的一半

<img src="img/9.png" alt="1577363436894" style="zoom:80%;" />

- 现有的jvm按照复制算法进行
  - 新生代：eden区，2个survivor区
    - 占比8：1：1
    - 98%的对象会被回收
  - 每次垃圾回收将eden区和一个survivor区存活的对象复制到另一个survivor区中
  - 如果survivor区的内存不够用，则从其他内存（老年代）进行分配担保
  - 好处
    - 只浪费了10%的内存空间，速度依然很快
  - 不足
    - 对象存活率较高时，需要进行较多的复制操作，效率变低



## 标记-整理法

- 老年代使用
- 对可回收对象进行标记
- 标记后存活的对象向===一端移动==
- 移动完成后，清理端边界以外的内存

<img src="img/10.png" alt="1577363881842" style="zoom:80%;" />



## 分代收集法

- 把java划分为新生代和老生代
- 不同年代的特点采用不同的收集算法
- 新生代
  - 复制算法
- 老生代
  - 标记-整理算法



# HotSpot 的算法实现



## 枚举根节点



## 安全点

- 程序执行时到安全点safepoint 暂停，进入stop the world



## 安全区域

- 扩展的safepoint



# 垃圾收集器

<img src="../database/redis/img/29.png" alt="image-20191228165121210" style="zoom:80%;" />

- 连线表示可以组合使用

- 没有最好的垃圾收集器，在不同的使用场景使用不同的垃圾收集器，达到最好的效果



## 新生代收集器



### Serial 收集器

- 连续收集器
- 最基本
- 单线程
- jdk1.3.1之前是唯一的收集器

![image-20191228165825991](../database/redis/img/30.png)

- 在进行safepoint时，所有线程进入stop the world
- 在新生代采用复制算法，在老生代采用标记-整理算法时，都是单线程操作
- 在client端模式下依然使用该收集器
  - 对于桌面应用，分配的内存一般不多，新生代一般几百兆，收集进入safepoint处理完成一般是几十ms
- 对于单核cpu好处
  - 没有线程交互和切换的开销



### ParNew 收集器

- Serial 收集器的多线程版本
- 收集算法，参数配置，回收策略，对象分配规则与Serial一样
- 与Serial共用很多代码

![image-20191228170345031](../database/redis/img/31.png)

- Server模式下首选新生代收集器
- 可以与CMS老生代收集器工作

- 使用-XX:+UseConcMarkSweepGC 默认收集器CMS后，新生代使用ParNew

- 使用-XX:+UseParNewGC选择 ParNew

- 默认开启收集线程数与CPU的数量相同
  - 使用-XX:ParallelGCThreads 限制垃圾收集的线程数

- 并行收集器



#### 关于并行和并发

- 并行
  - Parallel 
  - 多条垃圾收集线程并行工作，此时用户线程处于等待状态
- 并发
  - Concurrent
  - 用户线程与收集线程同时执行（可能是交替执行）
  - 用户线程在一个cpu上执行
  - 收集线程在另一个cpu上执行



### Parallel Scavenge 收集器

- Scavenge 打扫
- 使用复制算法
- 并行多线程
- 吞吐量优先收集器
- 关注点在于==可控吞吐量==
  - 其他收集器关注点是尽可能的在收集时==减少用户线程的等待时间== 

- 吞吐量
  - 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)
- 区别
  - 停顿时间短
    - 适合需要用户交互的程序
    - 响应速度快，提升用户体验
  - 高吞吐
    - 高效的利用cpu时间，尽快的完成计算任务
    - 适合在后台运算不需要太多的交互任务
- 参数
  - -XX:MaxGCPauseMillis 控制最大垃圾收集停顿时间
    - 大于0的ms数
    - 尽可能保证内存回收花费时间不超过该值
    - 该值越小，吞吐量越低，新生代空间越小
  - -XX:GCTimeRatio 设置吞吐量大小
    - 垃圾收集时间占总时间的比例
    - 大于0 小于100的整数
    - 如设置19，则最大GC时间占总时间的为1/(19+1) = 5%
    - 默认值99，1%
  - -XX:+UseAdaptiveSizePolicy 开关参数
    - 打开不需要手动指定新生代大小 -Xmn，Eden与Survivor的比例 -XX:SurvivorRatio，晋升老年代对象大小 -XX:PretenureSizeThreshold
    - 虚拟机自动依据当前系统运行情况收集性能监控信息
    - 自适应调节策略
    - 只需要设置-Xmx 最大堆



## 老年代收集器



### Serial Old 收集器

- 使用标记-整理算法

- 单线程
- 老年代使用
- 主要在Client端使用
- 在Server端使用作为CMS的后备方案
  - 在CMS发生Concurrent Mode Failure时使用

![image-20191228173750223](../database/redis/img/32.png)



### Parallel Old 收集器

- ==Parallel Scavenge==的老年代版本
- 多线程
- 并行
- 标记-整理算法

![image-20191228175121585](../database/redis/img/33.png)



### CMS 收集器

- 老年代使用

- Concurrent Mark Sweep
- 目标：最短回收停顿时间
- 适用于B/S架构服务
  - 重视响应速度
- 基于标记-清除算法

