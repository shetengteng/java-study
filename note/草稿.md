构建上下文

- 使用`docker build`的时候最后有一个 `.`

- 该`.` 就是上下文
- docker 是C/S架构，在安装docker后，可以发现安装了服务端和客户端
- 使用`docker build`构建镜像在服务端docker引擎构建，而非客户端
- 客户端输入构建命令，将路径下的所有内容打包，上传给docker引擎
- 引擎收到内容后展开，获取需要的文件
- 那么build输入的`.`是指当前路径下为==上下文路径==，将当前路径下的文件打包给docker引擎
- 分析命令

```sh
COPY ./package.json /app/
```

- 该命令中的./package.json文件指的是上下文路径中的package.json文件，而非本地客户端当前文件夹的文件

- Dockerfile文件默认在构建的当前目录下，也可指定路径`docker build -f /path/to/a/Dockerfile .`

  

Dockerfile指令

COPY

- 格式

```sh
COPY <源路径>... <目标路径>
COPY ["<源路径1>",... "<目标路径>"]
```

- ==从上下文目录==中的**源路径**的文件拷贝到镜像内的**目标路径**
  - 通配符规则要满足 Go 的 [`filepath.Match`](https://golang.org/pkg/path/filepath/#Match) 规则

```sh
COPY package.json /usr/src/app/
COPY hom* /mydir/
COPY hom?.txt /mydir/
```

- 特点
  - 源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等
  - 目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录
  - 可以是容器内的绝对路径，也可是相对于工作目录的相对路径（工作目录可以用 `WORKDIR`指令来指定）



ADD

- 性质与COPY相似

- 增加的功能

  - `<源路径>`可以是一个URL，Docker引擎会去下载链接的文件到`<目标路径>`

    - 设置默认权限600
    - 如果需要修改权限，需要RUN进行修改
    - 如果下载的是压缩包，需要RUN进行解压
    - 一般不推荐使用，而是先通过RUN wget下载后，解压，权限处理完成后ADD

  - `<源路径>`是一个tar文件，压缩格式为 `gzip`, `bzip2` 以及 `xz` ，`ADD`会自动解压到`<目标路径>`

    - 很实用，可以将官方镜像进行解压

    ```sh
    FROM scratch
    ADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /
    ...
    ```

    - 如果不希望进行解压，那么就不能使用`ADD`

- 适合的场景：带有压缩包的源文件
  - ADD包含了更多复杂的功能，行为不清晰，操作场景相同时推荐用COPY操作



CMD

- 格式

```sh
CMD <命令>
CMD ["可执行文件", "参数1", "参数2"...] # 推荐使用
```

- Docker容器不是虚拟机，是一个进程，进程在启动的时候可添加初始参数
- 用于指定默认容器主进程启动的命令

- ubuntu镜像默认的CMD是/bin/bash，那么执行如下命令

```sh
CMD echo $HOME
# 在执行时会转变为
CMD [ "sh", "-c", "echo $HOME" ]
# shell命令的环境变量可以使用，会被sh解析处理
```

- 更换默认CMD命令

```sh
docker run -it ubuntu cat /etc/os-release # 将/bin/bash替换为 cat /etc/os-release
```

- Docker容器中的程序都是前台执行的，不能后台执行

```sh
CMD service nginx start # 执行失败，会直接退出容器进程，会被理解为如下命令
CMD [ "sh", "-c", "service nginx start"] # 执行失败，正确的应该执行nginx的命令
CMD ["nginx", "-g", "daemon off;"] # nginx在前台执行
```



ENTRYPOINT



