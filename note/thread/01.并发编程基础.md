# 多线程基础



## 线程简述

一个java程序从main方法开始就是一个多线程程序

使用JMX查看一个普通的java程序包含了那些线程

```java
public class Ch06_JMXMainDemo {
	public static void main(String[] args) {
		// 获取java线程管理MXBean
		ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();
		// 不需要获取同步的monitor和synchronizer信息
		// 只获取线程和线程堆的信息
		ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(false,false);
		// 打印线程信息
		for (ThreadInfo threadInfo : threadInfos) {
			System.out.println(String.format("[%s] %s",
                threadInfo.getThreadId(),threadInfo.getThreadName()));
		}
	}
	// 结果
	//[6] Monitor Ctrl-Break 
	//[5] Attach Listener
	//[4] Signal Dispatcher 分发处理发送给JVM信号的线程
	//[3] Finalizer 调用对象的finalize方法的线程
	//[2] Reference Handler 清除reference的线程
	//[1] main 程序入口
}
```

### 优先级

- java中在线程构建的时候使用setPriority控制优先级
- 优先级范围1-10，默认优先级5

- 优先级高的，线程分配的时间片多，获取的资源越多

- 针对频繁==阻塞==的（休眠或者IO操作）的线程设置==高==优先级
- ==偏计算==的（需要较多的CPU时间或者偏运算）的线程设置较==低==的优先级

- 有些情况下，操作系统不理会java程序对优先级的设定。

### 线程状态

| 状态名称      | 说明                                                         |
| :------------ | ------------------------------------------------------------ |
| NEW           | 初始状态，被构建，没有调用start()                            |
| RUNNABLE      | 运行中状态，表示就绪和运行                                   |
| BLOCKED       | 阻塞<br /> 线程进入synchronized关键字修饰的方法或者代码块获取锁时<br />注意：==在concurrent包中Lock接口的线程状态是等待WAITING，而非BLOCKED状态== |
| WAITING       | 等待，进入等待状态的线程需要其他线程通知或中断               |
| TIMED_WAITING | 超时等待，不同于WAITING，在指定时间返回，调用sleep方法进入   |
| TERMINATED    | 终止，表示线程执行完毕                                       |

![1558686565420](img\01.thread31.png)

使用jstack分析（D:\java\jdk\jdk1.8.0_101\bin\jstack.exe）

```java
public class Ch07_ThreadStateDemo {
	/**
	 * 线程进行睡眠
	 */
	static class TimeWaiting implements Runnable{
		@Override
		public void run() {
			for(;;) {sleep(10);}
		}
	}
	/**
	 * 线程在等待
	 */
	static class Waiting implements Runnable{
		@Override
		public void run() {
			for(;;){
				synchronized (Waiting.class){
					try {
						Waiting.class.wait();
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				}
			}
		}
	}

	/**
	 * 阻塞测试
	 */
	static class Blocked implements Runnable{
		@Override
		public void run() {
			synchronized (Blocked.class){
				for(;;){
					sleep(10);
				}
			}
		}
	}
	public static void main(String[] args) {
		new Thread(new TimeWaiting(),"timeWaiting").start();
		new Thread(new Waiting(),"Waiting").start();
		// 使用2个线程获取锁，一个获取锁成功，一个阻塞
		new Thread(new Blocked(),"blocked-1").start();
		new Thread(new Blocked(),"blocked-2").start();
	}
	private static void sleep(long time){
		try {
			TimeUnit.SECONDS.sleep(time);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
}
```

输入jps，获取当前的pid

```shell
E:\java\code\base-demo\practise>jstack 19020
2019-05-24 16:42:34
Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.101-b13 mixed mode):
...
"blocked-2" #14 prio=5 os_prio=0 tid=0x0000000019e79800 nid=0x43ac waiting for monitor entry [0x000000001a6cf000]
java.lang.Thread.State: BLOCKED (on object monitor)
at com.stt.thread.part01_base.Ch07_ThreadStateDemo$Blocked.run(Ch07_ThreadStateDemo.java:47)
- waiting to lock <0x000000078d434430> (a java.lang.Class for com.stt.thread.part01_base.Ch07_ThreadStateDemo$Blocked)
at java.lang.Thread.run(Thread.java:745)

"blocked-1" #13 prio=5 os_prio=0 tid=0x0000000019e77000 nid=0x401c waiting on condition [0x000000001b03e000]
java.lang.Thread.State: TIMED_WAITING (sleeping)
at java.lang.Thread.sleep(Native Method)
at java.lang.Thread.sleep(Thread.java:340)
at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)
at com.stt.thread.part01_base.Ch07_ThreadStateDemo.sleep(Ch07_ThreadStateDemo.java:63)
at com.stt.thread.part01_base.Ch07_ThreadStateDemo.access$000(Ch07_ThreadStateDemo.java:9)
at com.stt.thread.part01_base.Ch07_ThreadStateDemo$Blocked.run(Ch07_ThreadStateDemo.java:47)
- locked <0x000000078d434430> (a java.lang.Class for com.stt.thread.part01_base.Ch07_ThreadStateDemo$Blocked)
at java.lang.Thread.run(Thread.java:745)

"Waiting" #12 prio=5 os_prio=0 tid=0x0000000019e76000 nid=0x5554 in Object.wait() [0x000000001ae0e000]
java.lang.Thread.State: WAITING (on object monitor)
at java.lang.Object.wait(Native Method)
- waiting on <0x000000078d431370> (a java.lang.Class for com.stt.thread.part01_base.Ch07_ThreadStateDemo$Waiting)
at java.lang.Object.wait(Object.java:502)
at com.stt.thread.part01_base.Ch07_ThreadStateDemo$Waiting.run(Ch07_ThreadStateDemo.java:30)
- locked <0x000000078d431370> (a java.lang.Class for com.stt.thread.part01_base.Ch07_ThreadStateDemo$Waiting)
at java.lang.Thread.run(Thread.java:745)

"timeWaiting" #11 prio=5 os_prio=0 tid=0x0000000019e75000 nid=0x52fc waiting on condition [0x000000001ad0f000]
java.lang.Thread.State: TIMED_WAITING (sleeping)
at java.lang.Thread.sleep(Native Method)
at java.lang.Thread.sleep(Thread.java:340)
at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)
at com.stt.thread.part01_base.Ch07_ThreadStateDemo.sleep(Ch07_ThreadStateDemo.java:63)
at com.stt.thread.part01_base.Ch07_ThreadStateDemo.access$000(Ch07_ThreadStateDemo.java:9)
at com.stt.thread.part01_base.Ch07_ThreadStateDemo$TimeWaiting.run(Ch07_ThreadStateDemo.java:17)
at java.lang.Thread.run(Thread.java:745)
```

### Daemon线程

- 在线程启动前使用setDaemon(true)设定为Daemon线程
- 所有非Daemon线程运行结束时，java虚拟机退出
- java虚拟机退出时，daemon线程的finally块不会执行。



## 启动终止线程

- 线程启动start()方法
- 先终止run()方法执行结束

### 构造线程

线程的初始化方法，Thread的init方法源码

```java
private void init(ThreadGroup g, Runnable target, String name,
                  long stackSize, AccessControlContext acc) {
    if (name == null) {
        throw new NullPointerException("name cannot be null");
    }
    this.name = name.toCharArray();
	//
    Thread parent = currentThread();
    SecurityManager security = System.getSecurityManager();
    if (g == null) {
        /* Determine if it's an applet or not */

        /* If there is a security manager, ask the security manager
               what to do. */
        if (security != null) {
            g = security.getThreadGroup();
        }

        /* If the security doesn't have a strong opinion of the matter
               use the parent thread group. */
        if (g == null) {
            g = parent.getThreadGroup();
        }
    }

    /* checkAccess regardless of whether or not threadgroup is
           explicitly passed in. */
    g.checkAccess();

    /*
         * Do we have the required permissions?
         */
    if (security != null) {
        if (isCCLOverridden(getClass())) {
            security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);
        }
    }

    g.addUnstarted();

    this.group = g;
    this.daemon = parent.isDaemon();
    this.priority = parent.getPriority();
    if (security == null || isCCLOverridden(parent.getClass()))
        this.contextClassLoader = parent.getContextClassLoader();
    else
        this.contextClassLoader = parent.contextClassLoader;
    this.inheritedAccessControlContext =
        acc != null ? acc : AccessController.getContext();
    this.target = target;
    setPriority(priority);
    if (parent.inheritableThreadLocals != null)
        this.inheritableThreadLocals =
        ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);
    /* Stash the specified stack size in case the VM cares */
    this.stackSize = stackSize;

    /* Set thread ID */
    tid = nextThreadID();
}
```



