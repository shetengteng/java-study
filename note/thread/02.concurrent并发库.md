# Concurrent并发学习

## 锁

### lock 接口

- synchronized
  - 隐式获取锁和释放锁
- lock接口
  - 显式的获取锁和释放锁
  - 可中断的获取锁和超时获取锁等多种操作
  - 尝试非阻塞获取锁，如果一个时刻获取锁，如果没有其他线程获取锁，则成功获取并持有锁
  - 可以被中断的获取锁，与synchronized不同，获取到锁的线程可以被响应中断，当获取到锁的线程被中断时，中断异常会被抛出，同时，锁会被释放。
  - 超时获取锁，指定的截止时间之前获取锁，如果超时仍旧无法获取锁，则返回。

```java
Lock lock = new ReentrantLock();
lock.lock(); // 获取锁的操作不要放在try中，如果获取锁失败抛出异常，会导致锁无故释放
try {
} finally {
	lock.unlock();
}
```

- api

| 名称                        | 描述                                                         |
| --------------------------- | ------------------------------------------------------------ |
| void lock()                 | 获取锁，调用该方法当前线程会获取锁，当锁获取后，从该方法返回 |
| void lockInterruptibly()    | 可中断的获取锁，响应中断，获取锁的时候，可以中断当前线程     |
| boolean tryLock()           | 尝试非阻塞的获取锁，调用该方法后，会立刻返回，返回true表示获取到锁 |
| boolean tryLock(time ,unit) | 超时获取锁，1 当前线程在超时时间内获取锁，2当前线程在超时时间内被中断，3超时时间结束，返回false |
| void unlock()               | 释放锁                                                       |
| Condition newCondition()    | 获取等待通知组件，该组件和当前的锁绑定，当前线程获取到锁可以调用该组件的wait方法，调用后，当前线程释放锁 |



### AbstractQueuedSynchronizer 队列同步器

- 使用模板方法模式实现

- 使用一个int成员变量表示同步状态（state）

- 内置FIFO队列完成线程的排队工作

- 子类继承同步器进行管理同步状态，定义若干同步状态获取和释放来实现自定义同步组件

  - 共享或独占获取同步状态，不同类型的同步组件
    - ReentrantLock
    - ReentrantReadWriteLock
    - CountDownLatch

- 锁：面向使用者，隐藏实现细节

- 同步器：面向锁的实现者，简化锁的实现方式，屏蔽同步状态管理、线程排队，等待和唤醒等

  - 同步队列，同步器有首节点和尾节点，没有成功获取同步状态的线程会成为节点加入到队列的尾部，加入队列的过程必须是线程安全的
  - compareAndSetTail是一个CAS方法，将当前节点设置为尾部节点

  ![1559023383909](img\01.thread34.png)

![1559023629853](img\01.thread35.png)

![1559023651757](img\01.thread36.png)

- ==同步队列中节点==获取锁的过程
  - 在acquireQueued方法中，当前线程自旋尝试获取同步状态
  - head节点是成功获取状态的节点，head在释放锁之后，唤醒队列中的其他节点
  - 后续节点自旋判断是否是head节点，是head节点，则获取同步状态，而不是同步状态的则==继续自旋（阻塞节点的线程）==
  - 遵守同步队列的FIFO原则

![1559024248263](img\01.thread37.png)

- 独占式同步状态获取流程

![1559024840783](img\01.thread38.png)

- 独占与共享式访问资源对比

![1559030345853](img\01.thread39.png)

写操作独占式访问，而读取是共享式访问。

### 重入锁















## 并发容器

## 框架

## 原子操作

## 工具类